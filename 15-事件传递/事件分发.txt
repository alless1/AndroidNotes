视图结构：
一个activity中包含一个PhoneWindow对象，PhoneWindow中包含一个DecorView（应该还有一个title）,DecorView包含的就是ViewRoot，ViewRoot里面就包含的是ViewGroup和View。
事件管理：
主要是通过WindowManagerService这个类来管理的。
事件传递：
事件传递主要就是涉及到三个类
1.dispatchTouchEvent.
2.onInterceptTouchEvent.
3.onTouchEvent.
因为Activity是事件传递的起始位置，View是事件传递的终止位置，都没有拦截事件的必要，所以这两个类是没有onIntereceptTouchEvent方法的。
首先是事件分发
会执行dispathTouchEvent，等待判断
然后是事件判断
如果是父控件会执行onInterceptTouchEvent
如果是子控件会执行onTouchEvent
最后是事件结果
如果事件判断是true,就是被消费了（被拦截等于被消费了），dispathTouchEvent返回true,让后将结果告诉上一层的dispathTouchEvent。
如果事件判断是false,
如果是viewGroup，就会把结果告诉下一层的dispathTouchEvent,下一层的内部再继续事件分发。
如果是view结果就已经出来了，dispathTouchEvent返回false,返回给上一层的onTouchEvent,上一层的dispathTouchEvent就得到了false。

在事件判断中，如果父类onIntercepTouchEvent拦截了，dispathTouchEvent的结果就出来了，没有其他什么事了。
如果父类onIntercepTouchEvent不拦截，那么dispathTouchEvent还要等子类的反馈结果（如果子类不要的话，自己的onTouchEvent再判断一次）,才能决定自己的结果。

在事件判断中，
只判断一次：如果onIntercepTouchEvent为true,或者onIntercepTouchEvent为false但是子类的dispathTouchEvent为true,那么父类的dispathTouchEvent就有结果了为true；
判断两次：如果onIntercepTouchEvent为false,并且子类dispathTouchEvent也为false,就会再判断自己的onTouchEvent，根据onTouchEvent的结果得出dispathTouchEvent结果。

如果父类拦截了，就不会传递给子类。
如果父类不拦截，子类拦截了，事件也会结束。
如果父类不拦截，子类也不拦截，父类还会通过onTouchEvent再判断一次，自己还要不要。

父类里面有两个判断方法，onInterceptTouchEvent，onTouchEvent，一个是发出去的时候判断，另一个是发回来的时候再判断一次（是子类不要的情况下）。

view只有一次判断机会，viewGroup可能有两次判断机会。