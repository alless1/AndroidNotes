强引用可能导致内存泄露。
handler可能导致内存泄露。



非静态内部类和非静态匿名内部类中确实都持有外部类的引用,在编译器编译过程中，帮我们隐式的传入了this这个参数，这也是为什么，我们平时在方法中能使用this这个关键字的原因.
了解了隐式引用，那么为什么它会是导致内存泄漏的根本原因？ 这里又得说明一下，虚拟机的垃圾回收策略。
java垃圾回收机制

垃圾回收机制：Java采用根搜索算法，当GC Roots不可达时，并且对象finalize没有自救的情况下，才会回收。

回收对象：GC会收集那些不是GC roots且没有被GC roots引用的对象。

解决方案

通过上述的分析，要预防非静态内部类的泄漏问题，就得管理好对象间的引用关系。
解决思路

    去除隐式引用（通过静态内部类来去除隐式引用）
    手动管理对象引用（修改静态内部类的构造方式，手动引入其外部类引用）
    当内存不可用时，不执行不可控代码（Android可以结合智能指针，WeakReference包裹外部类实例）

并不是所有的内部类只能使用静态内部类，只有在该内部类中的生命周期不可控制的情况下，我们要采用静态内部类，其它时候大家可以照旧。

如果了解了这些，比如Context、Handler、Timer、静态Acitivity、静态View、Thread等等造成的泄漏，也是能融会贯通的，只要大家多想一下它们之间的引用关系即可
